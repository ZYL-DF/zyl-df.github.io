---
title: 计算机组成原理 第四章
date: 2023.4.15
updated: 2023.4.15
tags: 
- 学习
- 计算机组成原理
categories: 
- 笔记
keywords:  
- 计算机组成原理
- 笔记
description: 支持王道考研谢谢喵~
toc: true
toc_number: false
katex: true
top_img: https://ichirinko-blog-img-1.oss-cn-shenzhen.aliyuncs.com/Pic_res/CSAPP/1-6/202210200028800.png
cover: https://ichirinko-blog-img-1.oss-cn-shenzhen.aliyuncs.com/Pic_res/PostCalendar/202304151150487.jpg
---

# 计组 第四讲 指令系统 3.30

## 指令系统的发展、性能要求

程序 - 用于解决实际问题的一系列的指令

指令 - 是计算机执行某种操作的命令

- 微指令：微程序集的命令，属于硬件
- 机器指令：可完成一个独立的算数或逻辑运算
- 宏指令：由若干条机器指令组成的软件指令，它属于软件



指令系统：一台计算机中所有机器指令的集合

> 直接影响机器的硬件结构、软件系统、以及机器的适用范围

<br>

### 系列计算机

- 基本指令系统、基本体系结构相同的一系列计算机，但具体的器件、结构和性能都不会完全相同

> 一般，新机种在各方面要优于旧机种

- 一个系列往往有多种型号，各型号计算机的指令系统是**向下兼容/向后兼容**的

- 新机种的指令系统包含旧机种的全部指令

<br>

### CISC

CISC（complex instruction set computer 复杂指令集）

采用复杂的的指令系统，来达到**增强计算机的功能、提高机器速度**的目的

特点：

- 指令系统复杂庞大，指令数目多
- 指令格式多，字长不固定，多种寻址方式
- 可访存指令不受限制
- 各种指令的执行时间相差很大
- 大都采用微程序控制器

<br>

### RISC

RISC（Reduced instruction set computer 精简指令集）

从简化指令系统和优化硬件设计的角度来**提高系统的性能与速度**

特点：

- 选取使用频率高的简单指令
- 指令长度固定，指令格式少，寻址方式种类少
- 采用**流水线技术**
- 使用较多的通用寄存器，减少访存
- 控制器以组合逻辑控制为主
- 采用优化编译技术

<br>

---

<br>

### 指令系统性能的要求

指令系统的性能决定了计算机的基本功能，它的设计直接关系到计算机的硬件结构和用户的需要

一个完善的指令系统应满足如下四方面的要求

- 完备性

  > 常用指令齐全，编程方便

- 有效性

  > 程序占用内存少，运行速度快

- 规整性

  > 指令和数据的使用规则统一，易学易记

  规整性还包括：

  - 对称性

    > 所有的指令都可使用各种寻址方式

  - 匀齐性

    > 一种操作性质的指令可以支持各种数据类型

  - 指令格式和数据格式的一致性

    > 指令长度和数据长度有一定的关系，以方便处理和存取

- 兼容性

  > 同一系列的低档计算机的程序能够在新的高档计算机上运行。

<br>

---

<br>

### 低级语言与硬件结构的关系

低级语言：面向机器的语言，和具体机器的指令系统密切相关，例如机器语言，汇编语言等

<br>

---

<br>

## 指令格式

**指令字**（简称指令）表示一条指令的机器字

**指令格式**用二进制代码表示的指令字结构形式，由操作码字段和地址码字段组成

**操作码字段：**表征指令的操作特性与功能

**地址码字段：**通常指定参与操作的操作数的地址

| 操作码字段OP | 地址码字段A |
| :----------: | :---------: |
|              |             |

<br>

### 操作码

操作码字段的位数取决于指令系统的规模

操作码的类型

- 固定长度的操作码

  > 所有指令长度均相同

  优点：**控制简单，速度快**，适用于指令条数不多的场合

  

  

  <br>

- 可变长度的操作码

  > 频繁使用的指令用位数较少的操作码
  >
  > 不常使用的指令可利用操作码扩展技术进行扩展
  >
  > Ep.操作码字段为4位，则指令系统中的指令数目为$2^4$=16条。

  优点：充分利用软硬件资源，适用于大规模的指令系统。

<br>

一条指令格式中有几个地址码字段，就称为是**几地址指令**

### 零地址指令(OP)

无任何操作数运算，如NOP、HALT等指令。

②单操作数运算：隐含一个操作数，如Acc。

$OP(Acc)\rightarrow Acc$

<br>

### 一地址指令(OP|A1)

①单操作数运算：$OP(A1)\rightarrow A1$

②双操作数运算：隐含一个操作数，如Acc. $(Acc)OP(A1)\rightarrow Acc/A1$

INC,MUL,CBW指令

<br>

### 二地址指令(OP|A1|A2)

$(A1)OP(A2)\rightarrow A1$

<br>

### 三地址指令（OP|A1|A2|A3）

$(A1)OP(A2)\rightarrow A3$

<br>

### 指令字长度

**机器字长**

运算器一次能处理的二进制数的位数

机器指令的长度直接决定着CPU运算的精度和直接寻址能力的大小

<br>

**指令字长**

一个指令字中包含二进制代码的位数

指令字长由操作码长度、操作数长度和个数共同决定

指令有半字长、单字长、双字长、多字长等不同的长度类型

> 比如说操作系统为16位，指令也为16位，那么就是单字长



指令系统可分为等长指令字结构、变长指令字结构两种



分为R/S型指令，分别表示寄存器和存储器

<br>

---

<br>

操作数类型

机器指令对数据进行操作，数据通常分为以下四类

- 地址数据

  > 无符号整数，通过某种运算确定操作数在主存中的有效地址

- 数值数据

  > 定点整数、小数；浮点数

- 压缩十进制数

  > 字符数据,文本数据或字符串

- 逻辑数据

  > 由若干二进制位组成，每位的值可以是1或0。

<br>

### 指令的寻址方式

**顺序寻址**

程序按顺序执行时的指令寻址方式

必须用**程序计数器**记录所要执行指令的存放单元地址

- 一般做**加1条指令**的操作
- 程序计数器又称指令指针寄存器



<br>

**跳跃寻址方式**



![computerComposition_4_1](https://ichirinko-blog-img-1.oss-cn-shenzhen.aliyuncs.com/Pic_res/PostCalendar/202304151141994.JPG)

先进行顺序寻址，当一句指令执行时，PC自增1，指向下一句，**因此当3号执行完后，PC=4**，此时读到`JMP 7`,于是**将PC改写为7**，跳转至7

<br>

---

<br>

## 操作数的寻址方式

| 操作码OP | 变址X | 间址I | 形式地址A |
| :------: | :---: | :---: | :-------: |
|          |       |       |           |

将指令中的形式地址A变换成操作数有效地址的过程，称为寻址过程



<br>

### 隐含寻址

![computerComposition_4_2](https://ichirinko-blog-img-1.oss-cn-shenzhen.aliyuncs.com/Pic_res/PostCalendar/202304151141009.JPG)

### 立即寻址

形式地址A就是操作数

优点： 指令执行阶段不需要访存，速度快

缺点：形式地址A字段的位数限制了立即数的范围

<br>

### 直接寻址

有效地址由形式地址字段A直接给出 EA=A

特点：

- 执行阶段访问一次存储器

- A的位数决定了该指令操作数的寻址范围

- 操作数的地址不易修改（必须修改A）

<br>

### 间接寻址

有效地址由形式地址字段A间接提供，EA=（A）

特点

- 可扩大寻址范围

  > A字段的长度受指令字长和指令格式的限制

  

- 寻址时，可根据需要进行多次间址

- 可用**寻址特制I字段**区分直接寻址和间接寻址方式；

<br>

### 寄存器寻址

形式地址字段A为寄存器编号 $EA=R_i$

特点

- 执行阶段不访存，只访问寄存器，执行速度快
- 寄存器个数有限，可缩短指令字长

<br>

### 寄存器间接寻址

形式地址字段A用于指出存放有效地址的寄存器编号 $EA=（R_i）$

特点：

- 执行阶段访存
- 便于编制循环程序



<br>

### 偏移寻址

直接寻址和寄存器间接寻址方式的结合 

有效地址是EA=A+（R）

- A是显式的形式地址字段
- R为某个专用的寄存器，可以为显式/隐含

#### 常用的偏移寻址

- 相对寻址：指令转移时，常用相对寻址方式：EA=A+（PC）
- 基址寻址：EA=（基址R）+A，$A+1\rightarrow A$
- 变址寻址：EA=（变址R）+A，$变址R+1\rightarrow 变址R$

<br>

