---
title: 离散数学第九章复习笔记（二）：群与编码
date: 2022.10.29
updated: 2022.10.29
tags: 
- 学习
- 离散数学
categories: 
- 笔记
keywords:  
- 离散数学
- 笔记
description: You are (not) tough
toc: true
toc_number: false
katex: true
top_img: https://ichirinko-blog-img-1.oss-cn-shenzhen.aliyuncs.com/Pic_res/CSAPP/1-6/202210200028800.png
cover: https://ichirinko-blog-img-1.oss-cn-shenzhen.aliyuncs.com/Pic_res/%E6%95%B0%E7%94%B5/1-3/202210292207165.jpg
---



# 第9章 群（Group）与半群（Semigroup）

## 9.1 再论二元运算（*binary operation*）

我们知道，集合A上的二元运算是一个处处有定义的函数$f:A×A\rarr A$

满足以下性质

- 二元运算必须为A的每个有序元素对而定义（对每个有序对都适用，**满射**）
- 每个有序对仅对应A中唯一的元素（**单射**）

采用 * 号来表示二元运算

再添加以下性质

- 运算* 下A是**封闭的（*closed*）**，$a,b\in A 那么 a*b\in A$
- 若对于$a,b\in A,a*b=b*a$,那么称A上的二元运算* 是**交换的（*commutative*）**，如果构造一张运算表，那么可以看到值是关于主对角线对称的
- 若对于$a,b,c\in A,a*(b*c)=(a*b)*c$,那么称A上的二元运算* 是**结合的（*associative*）**
- 若对于$a\in A,a*a=a$,那么称A上的二元运算* 是**幂等的（*idempotent*）**
- 设$A=\{x_1,x_2,...,x_n\}$含有n个元素,那么在$A$上存在$2^{n^2}$个二元运算



## 9.2 半群（*Semigroup*）

将一个非空集合$S$,以及定义在$S$上的**可结合的**二元运算*，构成以下结构
$$
(S,*)
$$
就表示半群

- 可以把$a*b$看成a和b的积
- 如果* 是一个交换运算，就称半群$(S,*)$是一个**交换半群**。
- 对$A=\{a_1,a_2,...,a_n\}$,有$A^*$是$A$中元素的所有有限序列的集合，在$A^*$上有二元运算$\cdot{} $,代表连接运算（看成字符串拼接就行），那么这个 $\cdot$ 运算是结合的，所以半群$(S,\cdot)$是由A产生的**自由半群（*free semigroup generated by A*）**。

<br>

---

接下来是一些概念

**单位元（*identity element*）**	$e$是$(S,*)$中的一个元素，对所有$a\in S$都有
$$
e*a=a*e=a
$$
称e为单位元，是唯一的

<br>

**幺半群（*monoid*）**	有单位元的半群$(S,*)$

<br>

<br>

**子半群（*subsemigroup*）**	有一半群(S,* ),若$T$是$S$的一个子集，且$T$在运算  * 下是封闭的，就称$(T,* )$是$(S,*)$的子半群

<br>

**子幺半群（*submonoid*）**	与子半群类似，有一幺半群(S,* ),若$T$是$S$的一个子集，且$T$在运算  * 下是封闭的，且$T$也含有单位元e，就称$(T,* )$是$(S,*)$的子幺半群

<br>

---

<br>

### 同构（*Isomorphism*）

$(S,*)$和$(T,*^{'})$两个半群，若函数 $f:S\rarr T$ 是从 $S$ 到 $T$ 的一个一一对应，而且对所有$a,b\in S$都有 $f(a*b)=f(a)*^{'}f(b)$ ,则称 $f:S\rarr T$ 是从 $(S,*)$ 到 $(T,*^{'})$ 的一个**同构**

说人话就是：

两个半群S和T，存在一个函数f，变量为S，结果为T，满足单射，满射，且f(a*b)=f(a) *' f(b),那么f就是从S到T的一个同构

- $f^{-1}$也是一个同构，从T到S
- S和T是同构的，就记为S=T

<br>

证明半群$(S,*)$,$(T,*^{'})$同构的一般步骤为

- 先定义一个函数$f:S\rarr T,Dom(f)=S$,Dom表示f的前域
- 证明 $f$ 是单射
- 证明 $f$ 是满射
- 证明 $f(a*b)=f(a)*'f(b)$

<br>

来道题就懂了

>**设T是所有偶数的集合，证明半群(Z,+)与(T,+)是同构的**
>
>定义 $f:Z\rarr T$ 满足f(a)=2a
>
>先证明单射。假设f(a1)=f(a2),那么就有2a1=2a2，所以a1=a2，因此f就是单射
>
>再证明满射。假设b是任意偶数，那么就有 $b/2=a\in Z$ ,且$f(a)=f(b/2)=2(b/2)=b$,故f为满射
>
>最后，f(a+b)=2a+2b=f(a)+f(b)
>
>故他们是同构的

<br>

<br>

### 同态（*homomorphism*）

在两个半群同构的条件下，去掉满足单射，满射的条件，即设$(S,*)$和$(T,*')$是两个半群，如果一个处处有定义的函数 $f:S→T$ 对于 $S$ 中的所有a和b有 $f(a*b)=f(a)*'f(b)$ ，则称$f$是从 $(S,*)$ 到 $(T,*')$ 的一个**同态**。如果 $f$ 还是满射，则称 $T$ 是 $S$ 的**同态象(*homomorphic image*)**。



> 同构与同态的差异就是同构必须单射和满射，相同之处就是都必须有积的象等于象的积

<br>

**定理：** 设$(S, *)$和$(T， *')$分别是有单位元$e$和$e'$的幺半群，$f:S→T$是从$(S,*)$到$(T,*')$的一个同态且是满射，那么$f(e)=e'$。
<br>

**定理：** 设 $f$ 是从半群$(S,*)$到半群$(T,*')$的一个同态，如果 $S'$ 是$(S,*)$的一个子半群，那么
$$
f(S')=\{t\in T|t=f(s)，对s\in S'\}
$$

即在 $f$ 下 $S'$ 的象是 $(T,*')$ 的一个子半群。

<br>

因此，$f(S')$在运算$*'$下是封闭的。因为结合性质在$T$中成立，所以它在$f(S')$中也成立，因此，$f(S')$是$(T,*')$的一个子半群。

<br>
**定理 :** 如果$f$是从交换半群$(S，*)$到半群$(T,*')$的一个同态且是满射，那么$(T,*')$也是交换半群。

<br>

<br>

---

<br>

## 9.3 半群的积与商（*PRODUCTS AND QUOTIENTS OF SEMIGROUPS*）

看标题就知道，半群进行积与商的运算，将会从已有的半群产生新的半群，这一节就是阐述新半群与老半群的关系

**定理：** 如果$(S,*)$和$(T,*')$是半群，那么$(S×T,*'')$是一个半群，其中$*''$由$(s_1,t_1)*''(s_2,t_2)=(s_1*s_2,t_1*'t_2)$定义

> 也就是说，假设S和T是分别有单位元e1，e2的幺半群，那么S×T是有单位元（e1，e2）的幺半群

<br>

---

### 同余关系（*congruence relation*）

如果 $aRa'$ 和 $bRb'$ 能够推出$(a*b)R(a'*b')$,那么这个在半群$(S,*)$上的**等价关系** $R$ 称为一个**同余关系**

> 要证明R是某一半群$(S,*)$上的一个同余关系
>
> 先证明R是一个等价关系（自反，对称，传递）
>
> 再证明同余关系的$aRa'$ ， $bRb'$ 能够推出$(a*b)R(a'*b')$

<br>

---

<br>

### 商半群 *quotient semigroup*（因子半群）*factor semigroup*

我们已经知道，半群上的等价关系决定半群的一个划分。

对半群$(S,*)$上的关系$R$,设$[a]=R(a)$是包含a的等价类，$S/R$表示所有等价类的集合。

**定理：** 设$R$是半群$(S,*)$上的一个同余关系，我们可以考虑一个从$S/R×S/R$到$S/R$的关系$\circledast$

- $\circledast$是从$S/R×S/R$到$S/R$的一个函数，用$[a]\circledast [b]$表示$\circledast ([a],[b])$。因此可以得出
  $$
  [a]\circledast [b]=[a*b]
  $$

- $(S/R,\circledast)$是一个半群，称为**商半群**或**因子半群**。

<br>

可以得出以下推论：

- $R$是幺半群$(S,*)$上的同余关系，若运算$\circledast$满足$[a]\circledast [b]=[a*b]$,那么$(S/R,\circledast)$也是一个幺半群

<br>

接下来说明的都是半群与商半群之间的关系

**定理：** 设R是半群(S,*)上的一个同余关系，$(S/R,\circledast)$是对应的商半群，那么由$f_R(a)=[a]定义的函数f_R:S\rarr S/R$是一个满射的同态，称其为**自然同态**

<br>

**同态基本定理：**设$f:S\rarr T$是半群$(S，*)$到半群$(T,*')$的一个同态，$R$是$S$上的关系，且$R$被定义为对于$S$中的a和b，aRb当且仅当$f(a)=f(b)$。那么有以下的结果：

- $R$是一个同余关系
- $(T,*')$和商半群$(S/R,\circledast)$是同构的

<br>

<br>

---

<br>

## 9.4 群

幺半群的集合中所有元素都拥有逆元且逆元在该集合中，则称该幺半群为**群**,表示为$(G,*)$

> **逆元（*inverse*）**	对于每个元素$a\in G$,都存在元素$b\in G$,使得$a*b=b*a=e$,则$a，b$互为逆元

也就是说一个普通的代数系统要成为群需要满足下面几个条件：

- 代数系统中只有一个二元运算,G在*下一定是封闭的。

- 该运算要满足结合律。

- 该运算要有单位元e。 

- 集合每个元素都有逆元且逆元在集合中。 

例如<C, +>, <R, +>, <Q, +>为群, 而<R, *>不再为群， 因为0没有逆元。

<br>

### 阿贝尔群（*Abelian*）

对于群G中的所有元素a，b有
$$
ab=ba
$$
那么群G就是阿贝尔群

- 对幺半群$Z_n$,[n-a]是[a]的逆，证明了$Z_n$也是一个阿贝尔群

<br>

### 群的一些基本性质

- 群G中的每个元素a在G中有且仅有一个逆元，记为$a^{-1}$

  > 那么上面那条逆元的定义式可以改成$aa^{-1}=a^{-1}a=e$

   

- （左/右消去性质）ab=ac 推出 b=c ，ba=ca 推出 b=c

   

- 设$a \in G,M_a:G\rarr G$满足$M_a(g)=ag$，那么$M_a$是单射

   

- $(a^{-1})^{-1}=a$

- $(ab)^{-1}=b^{-1}a^{-1}$    

   

- $a,b\in G$,方程ax=b和ya=b在G中都只有唯一解

<br>

### 对称群（*symmetric group*）

n个元素的所有置换的集合在合成运算下是一个阶为n！的群，称这个群为**n个字母上的对称群**，用$S_n$表示

<br>

<br>

---

<br>

### 子群（*subgroup*）

设$H$是群$G$的一个子集，若满足以下条件

- G中的单位元$e$属于$H$(有单位元)
- $a,b\in H,ab\in H$(封闭性)
- $a\in H,a^{-1}\in H$(有逆元)

则称H为G的一个**子群**

> 有单位元，存在封闭性，说明H是G的子幺半群，所以一个子幺半群如果有逆元，那就是一个子群

<br>

以下是一些更深的定义

#### 平凡子群（*trivial subgroup*）

在群$G$中，$G$和$H=\{e\}$是$G$的子群，称他们是$G$的平凡子群

<br>

#### 交错群（*alternating group*）

这个的前置条件是偶置换，没学，不说了

<br>

**定理：** 设$(G,*)$和$(G',*')$是两个群，$f:G\rarr G'$是从$G$到$G'$的一个同态

- 若$e$是$G$的单位元，$e‘$是$G’$的单位元，那么$f(e)=e'$
- 若$a\in G$,那么$f(a^{-1})=(f(a))^{-1}$
- 若$H$是$G$的一个子群，那么 $f(H)=\{f(h)|h\in H\}$是$G'$的一个子群

<br>

<br>

---

<br>

### 9.5 群的积与商（*PRODUCTS AND QUOTIENTS OF GROUPS*）

**定理：** 如果$G_1$和$G_2$是群，那么$G=G_1×G_2$是二元运算由$(a_1,b_1)(a_2,b_2)=(a_1a_2,b_1b_2)$定义的群，当然了，这个运算可以推广到$G_n$

**定理：** 设$R$是群$(G,*)$上的一个同余关系，那么半群$(G/R,\circledast)$是一个群，运算$\circledast$定义在$G/R$上且满足$[a]\circledast [b]=[a*b]$

<br>

**定理：** 设R是群(G,*)上的一个同余关系，那么由$f_R(a)=[a]定义的函数f_R:G\rarr G/R$是群的同态

<br>

**定理：** 设$f:G\rarr G'$是群$(G，*)$到群$(G',*')$的一个同态且是满射，$R$是$G$上的关系，且$R$被定义为对于$G$中的a和b，aRb当且仅当$f(a)=f(b)$。那么有以下的结果：

- $R$是一个同余关系
- 由$\overline f([a])=f(a)$给出的函数$\overline f:G/R\rarr G'$是从群$(G/R,\circledast)$到$(G',*')$的一个同构且是满射

<br>

### 左培集与右陪集（*left/right coset*）

群G有一子群H，$a\in G$,

由$a$决定的G中H的左陪集是集合
$$
aH=\{ah|h\in H\}
$$
由$a$决定的G中H的右陪集是集合
$$
Ha=\{ha|h\in H\}
$$
a称为陪集的代表元素

若对G中所有的a有aH=Ha，则称G的子群H是**正规子群（*normal subgroup*）**

> 这其实是说明了对a定义的左陪集aH，其实就是a在G上的一个等价类[a]

<br>

- 阿贝尔群的每个子群都是一个正规子群
- $R$是群G上的一个同余关系，H=[e]，即包含单位元的等价类，那么H是G的一个正规子群，并且对每个$a\in G$,$[a]=aH=Ha$

<br>

**定理：** 设N是群G的一个正规子群，R是G上的关系，满足aRb当且仅当$a^{-1}b\in N$,那么有

- R是G上的同余关系
- N是关于R的等价类[e]，其中e是G的单位元

<br>

<br>

从以上定理可以看到，如果G是任意一个群，**那么G上的同余关系的等价类总是G的某个正规子群的陪集**。反之，G的任意一个正规子群的陪集恰好是关于G上某个同余关系的等价类。所以，现在可以作如下解释:设$f$是从群$(G,*)$到群$(G',*')$上的同态并且是满射，$f$的**核**记做$ker( f )$，定义为
$$
ker(f)=\{a\in G|f(a)=e'\}
$$
那么

- ker( f )是G的一个正规子群
- 商群G/ker( f )与G'是同构的



<br>

<br>

---

<br>

### 环

特别地，令$S$是一个非空集合，在它上面定义了两种二元运算$＋$和$*$使得$(S,+,*)$是一个阿贝尔群，而* 对于＋满足分配律。(这两种运算符号与人们最熟悉的实数运算结构相同。）

如果* 满足结合律，那么结构$(S，＋，*)$称作一个**环**。

如果* 同时满足结合律和交换律,则称$(S，＋，*)$为**交换环**。

如果$(S，*)$是一个幺半群，则称$(S，＋，*)$为**含幺环**。

$*$的单位元通常用1表示，＋的单位元通常用0表示。

<br>

<br>

---

<br>

# 第11章 编码

## 11.1 编码

## 11.2 译码与纠错

一个满射函数$d:B^n\rarr B^m$称为与e有关的（n，m）译码函数。

设e是一个(m, n)编码函数，d是与e相关的一个(n, m)译码函数。如果无论x=e(b)是正确地传输还是有k个或更少的错误传输并且接收的是$x_t$，都有$d (x_t)=b$，则称数据对(e, d)校正k个或更少的错误。因此，从$x_t$能够译出正确的报文b。

<br>

已知一个(m,n)编码函数$e:B^m→B^n$，常常需要确定与e相关的一个(n, m)译码函数$d:B^n→B^m$。下面讨论一种方法，称作**最大似然方法**，它从一个已知e确定一个译码函数d。

- 因为$B^m$有$2^m$个元素，所以在$B^n$中存在$2^m$个代码字。首先以一种固定的次序列出代码字
  $$
  x^{(1)},x^{(2)},...,x^{(2m)}\\
  $$
  
- 假设我们通过e收到的字是$x_t$，我们要从这$2^m$个代码字里面，用$x_t$和每一个代码字（这里用$i$表示第$i$个，$1\le i \le 2^m$)，计算汉明距离$\delta (x^{(i)},x_t)$。

  > 汉明距离$\delta (x^{(i)},x_t)=|x^{(i)}\oplus x_t|$

- 按照汉明距离从小到大排列，选出距离最小且原始排序靠前的那一个代码字，也就是与$x_t$最接近的那一个代码字，记为$x^{(s)}$。

- 我们由上述操作求到了$x^{(s)}$，又已知$x^{(s)}=e(b)$，那么我们可以通过用以下函数

$$
\\d(x_t)=b\\
$$



来定义与e有关的**最大似然译码函数** $d$

<br>

---

<br>

**定理：** 已知e是一个(m,n)编码函数，d是与e有关的最大似然译码函数，那么(e,d)能纠正$\  k$个或更少的数，当且仅当e的最短距离至少是$2k+1$

> 直接上题目好理解：e的最短距离假设为3，那么有$3\ge 2k+1,也就是k\le 1$。也就说明了能纠正至多1个错误

<br>

接下来，我们要采用一种方法，来方(fu)便(za)地求出与e有关的**最大似然译码函数** $d$

我们需要一条**定理：** 如果K是群G的一个有限子群，那么G中K的每一个左陪集与K恰好有同样多的元素。

<br>

设$e:B^m\rarr B^n$是一个(m, n)编码函数并且是一个群码。
因此，$B^n$中的代码字集合$N$是B的一个子群,它的阶是$2^m$，如$N=\{x^{(1)},x^{(2)},...,x^{(2^m)}\}$

<br>

从上面的分析，我们再次假设代码字$ x=e(b)$被传输并且收到的字是$x_t$。$x_t$的左陪集是
$$
x_t\oplus N=\{\epsilon_1,\epsilon_2,...,\epsilon_{2^m}\},\\

\epsilon_i=x_t\oplus x^{(i)}
$$




从$x_t$到代码字$x^{(i)}$的距离恰好是$\epsilon_i$的权$|\epsilon_i|$。

因此，如果存在一个$\epsilon_j$,是陪集成员中的最小权，那么$x^{(j)}$一定是最接近$x_t$的代码字。

此时，$x^{(j)}=\epsilon_j\oplus x_t$

我们称一个有最小权的$\epsilon_j$为**陪集首部（*coset leader*）**，它不是唯一的

<br>

接下来，我们开始进行求解过程

**如果$e:B^m→B^n$是一个群码，要求他的最大似然译码函数d，需要**

- 确定$B^n$中的所有左培集

- 对每个陪集求陪集首部，也就是求其中具有最小权的字。

  <br>

  我们可以采用列表法来确定$B^n$中$N$的所有陪集，已知$N=\{x^{(1)},x^{(2)},...,x^{(2^m)}\}$,其中$x^{(1)}=\overline 0$

  <br>

  第一行：从单位元 $\overline0$ 开始，列出 $N$ 中的所有元素

  

  $\overline0$		  $x^{(2)}$	....	  $x^{(2^m)}$

  

  这其实是陪集[ $\overline 0$ ]，$\overline 0$ 就是它的陪集首部，也就是$\epsilon_1$

  <br>

  现在选择未列在第一行里$B^n$中的任意字 $y$。把陪集 $y\oplus N$ 中的元素列作第二行，该陪集也有2"个元素。

  $y\oplus\overline0$		  $y\oplus x^{(2)}$	....	  $y\oplus x^{(2^m)}$

  

  在陪集$y\oplus N$中,选取一个最小权的元素作为陪集首部，用$\epsilon_2$表示。万一最小权元素不止一个，则选取最小权中任意一个元素即可。

  <br>

  依次类推，下一行选择没有在前两行的任意字，选出最小权元素作为陪集首部，最后得表

![image-20221028114606931](https://ichirinko-blog-img-1.oss-cn-shenzhen.aliyuncs.com/Pic_res/%E6%95%B0%E7%94%B5/1-3/202210281146985.png)

- 最后，我们将需要进行译码的 $x_t$ 在表中找出，他所在的那一列的列头就是代码字$x^{(i)}$，用 $d(x^{(i)})$ 回去找对应的 $b$ 即可。

---

<br>

如果我们知道(m, n)群码是$e_H:B^m→B^n$，其中$H$是已知的奇偶校验矩阵。在这种情况下，可以简化上面的译码方法。
$$
H=\begin{bmatrix}
h_{11}&h_{12}&\cdots&h_{1r}\\
h_{21}&h_{22}&\cdots&h_{2r}\\
\vdots&\vdots&&\vdots\\
h_{m1}&h_{m2}&\cdots&h_{mr}\\
1&0&\cdots&0\\
0&1&\cdots&0\\
\vdots&\vdots&&\vdots\\
0&0&\cdots&1\\
\end{bmatrix}
$$




由$f_H(x)= x *H$定义的函数$f_H:B^n→B^r$是从群$B^n$到群$B^r$的一个同态。

由**定理：** 如果$m, n, r, H$以及$f_H$如上定义，那么$f_H$是满射

可得，
$$
g(xN)=f_H(x)=x*H
$$




元素$x*H$就是 $x$ 的**校验子(*syndrome*)**.

**定理：** 设x和y是$B^n$中的元素,那么x和y属于 $B^n$ 中 $N$ 的相同左陪集当且仅当$f_H(x)=f_H(y)$,即当且仅当它们有相同的校验子。

<br>

于是，我们得出了更简便求最大似然译码函数的方法：

- 确定$B^n$中 $N=e_H(B^m)$的所有左陪集
- 对每个陪集，求陪集首部并且计算所有首部的校验子
- 如果收到$x_t$,计算$x_t$的校验子并且求具有相同校验子的陪集首部$\epsilon$。那么$x_t\oplus \epsilon=x$是代码字$e_H(b)$，所以$d(x_t)=b$。



对于上面这个过程，不需要保存一张陪集表，并且能够避免计算译码表的工作量。而只要简单地以任意顺序一次列出所有陪集，并且从每个陪集中选择一个陪集首部。然后保存这些陪集首部和它们的校验子的一张表。上面的步骤很容易用这张表实现。

<br>

来道例题说明：

考虑奇偶校验矩阵
$$
H=\begin{bmatrix}
1&1&0\\
1&0&1\\
0&1&1\\
1&0&0\\
0&1&0\\
0&0&1\\
\end{bmatrix}
$$




和（3，6）群$e_H:B^3\rarr B^6$.

得到代码字

>还记得代码字怎么求吗？
>
>我们知道m和n，就能从$B^m$中的每个元素中构造内容为n的一个字
>
>比如m=3，n=6
>
>$B^m$有一个元素 010,
>
>那么我们就构造一个字，个数为6，就是$010x_1x_2x_3$
>
>$x_1=b_1h_{11}+b_2h_{21}+b_3h_{31}=1$
>
>$x_2=b_1h_{12}+b_2h_{22}+b_3h_{32}=0$
>
>$x_3=b_1h_{13}+b_2h_{23}+b_3h_{33}=1$
>
>那么代码字就是010101
>
>要注意算x1,x2,x3的时候，和式中只有含有奇数个1，结果才能为1
>

$$
\begin{align*}
\begin{split}
代码字 \left \{
\begin{array}{ll}
    e(000)=000000\\
    e(001)=001011\\
    e(010)=010101\\
    e(011)=011110\\
    e(100)=100110\\
    e(101)=101101\\
    e(110)=110011\\
    e(111)=111000\\
\end{array}
\right.
\end{split}
\end{align*}
$$






因此$N=\{000000,001011,010101,011110,100110,101101,110011,111000\}$

| 检验子 | 陪集首部 |      |
| :----: | :------: | ---- |
|  000   |  000000  |      |
|  001   |  000001  |      |
|  010   |  000010  |      |
|  011   |  001000  |      |
|  100   |  000100  |      |
|  101   |  010000  |      |
|  110   |  100000  |      |
|  111   |  001100  |      |

计算$x_t*H$,得到检验子=101，陪集首部$\epsilon$=010000，

那么再将$x_t \oplus \epsilon$,得到011110，

对应的e（011）=011110，则b=011

> 在进行$x_t*H$的运算时，是$x_t$所在的这一横行分别乘以$H$每一列的每个元素，再相加。特别要注意的是，最后相加时，等式中含有奇数个1，结果才是1，否则含有偶数个1的话，结果为0